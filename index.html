<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Space of liukai93">
<meta property="og:url" content="http://lk1ngaa7.github.io/index.html">
<meta property="og:site_name" content="Space of liukai93">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Space of liukai93">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://lk1ngaa7.github.io/"/>





  <title>Space of liukai93</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Space of liukai93</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lk1ngaa7.github.io/2017/02/11/hijack-on-network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liukai93">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Space of liukai93">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/11/hijack-on-network/" itemprop="url">链路劫持小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-11T22:11:56+08:00">
                2017-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在处理了一些HTTP劫持的案例和拜读业内不少大牛的文章之后，觉得有必要把最近的一些关于劫持案例的分析和思考记录下来，以留作日后备忘。<br>简单谈一下目前遇到的一个案例：<br>​    劫持者应该是利用在运营商内部的便利条件，在网关路由器上添加嗅探程序，嗅探明文HTTP请求数据包，拿到要劫持的数据包之后，马上给请求者返回HTTP response（302 到其他 url），并且立即关闭当前HTTP 请求。劫持者 302 的 url 是原网站的一个计费请求，类似淘宝推广链接。但是比较让人郁闷的是，劫持者返回的数据包是两个 TCP 数据包，偶尔会出现 TCP 报乱序（劫持技术不过关），导致客户端无法识别，从而导致页面白屏，严重影响用户体验！<br>下面介绍一下我是如何从数据包分析和定位劫持路由的：<br>案例背景:</p>
<p>山西移动部分地区，访问国内某中文导航网站出现白屏现象。</p>
<p>页面请求后得到奇怪数据返回：<br><img src="http://7j1zp6.com1.z0.glb.clouddn.com/imageshttpjiechi-1.png" alt=""><br>​    请求中 Connection 字段为 keep alive 且请求协议是 1.0 而返回的header 关闭了请求，返回一段奇怪的js，跳转到另外一个 url。<br>接下来观察 TCP flow：<br>​    这次TCP 连接上有 2 个奇怪的现象，都可以证明这是一次处于链路中的劫持，之后如果遇到类似的情况也可以从这两个方面入手来处理：</p>
<ol>
<li>server 给 client 的 TCP 报的 TTL 不一致，且抖动很大。</li>
<li>server 给 client 的 IP identification  ，出现不符合 RFC 标准的情况<br>TTL 不一致的情况：<br><img src="http://7j1zp6.com1.z0.glb.clouddn.com/imageshttpjiechi-2.png" alt=""><br>​    客户端接受的数据包TTL是 51 ，后面来自真实 server 的TTL 是 47，还有 1022 和 1024（本来应该在前面） 都是两个来自 劫持者的数据包，但是 fin 包在前，提前关闭连接，导致HTTP应用层拿不到正确的数据，导致浏览器白屏。<br><img src="http://7j1zp6.com1.z0.glb.clouddn.com/imageshttpjiechi-3.png" alt=""><br>这次 TCP 连接上的其他数据包，可以看到有部分数据包，被抛弃，而且被抛弃的数据包的 TTL 和 握手包的TTL 相等（一般握手包不会被劫持，说明被抛弃的包是来自 真实的服务器的）是 47 。<br>2 . IP identification 异常现象：<br>RFC定义：<br><img src="http://7j1zp6.com1.z0.glb.clouddn.com/imageshttpjiechi-4.png" alt=""><br>所以对于给定地址和协议的 ip 包来说，它的identification应该是公差为 1 的单调递增数列：<br>但是在这次连接中，劫持者的 identification 等于被劫持的 identification：<br>劫持者：<br><img src="http://7j1zp6.com1.z0.glb.clouddn.com/imageshttpjiechi-5.png" alt=""><br>被劫持者：<br><img src="http://7j1zp6.com1.z0.glb.clouddn.com/imageshttpjiechi-6.png" alt=""><br>仔细看，可以发现 993 和 1022 这两个包的identification 是一样的，多次抓包也是这样，所以这里可以判断，链路上肯定出了问题。<br>从这以上两个特征，基本上可以得出结论：<br>劫持者提前给浏览器返回了响应，且关闭了 HTTP 连接。导致正确的 数据包没有被接受，使得浏览器发生了异常跳转。而用户页面出现白屏的情况是劫持失败，劫持者的数据包乱序（程序错误），导致应用层无法获得争取 HTTP 响应。<br>劫持过程应该类似于：<br><img src="http://7j1zp6.com1.z0.glb.clouddn.com/imageshttpjiechi-7.png" alt=""><br>结论已经获得，但是问题的解决就是要定位到相应的劫持路由，然后向有关部门反馈：<br>定位的方法我推荐几种：</li>
</ol>
<ol>
<li><p>如果出现一定数量的用户反馈，可以多联系几位用户（不同网路环境下(wifi,手机热点)，能复现劫持），抓包，然后获取 trace 截图，如果他们出现某几跳路由的重复，就可以缩小定位范围，或者直接定位路由IP。</p>
</li>
<li><p>根据劫持包的TTL反推，用scapy来构造自定义的，可以复现劫持的HTTP请求包，然后以TTL从1开始递增发包，出现劫持响应时，可以判断劫持者的位置。</p>
<p>参考文章：<br><a href="http://www.freebuf.com/vuls/62561.html" target="_blank" rel="noopener">http://www.freebuf.com/vuls/62561.html</a><br><a href="http://security.tencent.com/index.php/blog/msg/10" target="_blank" rel="noopener">http://security.tencent.com/index.php/blog/msg/10</a><br>谢谢这两篇文章的作者，指定迷津。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lk1ngaa7.github.io/2016/04/11/javascript-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liukai93">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Space of liukai93">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/11/javascript-notes/" itemprop="url">javascript-一些学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-11T19:07:42+08:00">
                2016-04-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaScript-事件"><a href="#JavaScript-事件" class="headerlink" title="JavaScript 事件"></a>JavaScript 事件</h1><p><strong>事件类型</strong></p>
<p>按照事件添加的区别，分为DOM 0 级事件和DOM 2 级事件。</p>
<p>DOM 0 级事件类似于下面的这样添加:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a onclick=<span class="string">"alert(event.type)"</span> &gt;link&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string"> document.getElementByTag('a')[0].onclick = alert(event.type);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样添加的优点是，几乎所有的浏览器都是兼容的。而且简单。缺点是一个元素的事件只能绑定一个事件处理程序。而且这个事件处理程序添加方式不能支持事件捕获，只能使用事件冒泡机制。</p>
<p>DOM 2 级事件添加方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">e.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="string">'hello javascript'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>这样做的优点是一个元素的一个事件可以绑定多个事件处理程序，事件执行的顺序与添加的顺许相关，例如上面的示例，依次输出 ‘hello world’ , ‘hello javascript’ . 方法的第三个参数表示处理程序是在冒泡阶段执行还是在捕获阶段执行。</p>
<p>但是这样的添加方式可能会在不同版本的浏览器存在兼容性问题，例如在IE中DOM 2 级的事件处理程序添加是这样来写的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e.attachEvent(<span class="string">'onclick'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">e.attachEvent(<span class="string">'onclick'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="string">'hello javascript'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>区别主要是第一个参数需要添加 ‘on’ ，其次还有主要是添加的事件处理程序的执行顺序不同，这次首先输出 ‘hello javascript ‘ ,    然后再输出 ‘hello’，IE和opera 只支持事件冒泡。所以没有第三个参数。</p>
<p>各大浏览器之间的事件绑定程序添加方式不同，所以需要添加一个兼容的事件添加程序来保证兼容性。可以像这样一个简单的对象来处理事件添加。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Event = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">type, e, foo</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.addEventListener) &#123;</span><br><span class="line">            e.addEventListener(type, foo, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.attachEvent) &#123;</span><br><span class="line">            e.attachEvent(<span class="string">'on'</span> + type, foo, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            e[<span class="string">'on'</span> + type] = foo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span>(<span class="params">type, e, foo</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.removeEventListener) &#123;</span><br><span class="line">            e.removeEventListener(type, foo, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.detachEvent) &#123;</span><br><span class="line">            e.detachEvent(<span class="string">'on'</span> + type, foo);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            e[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件出发后，浏览器的处理方式也是不一样的，主要有冒泡和捕获方式。例如：IE 只支持冒泡。NetScape 只支持捕获，为了保持浏览器之间的兼容性，W3C制定了首先进入捕获阶段，然后进入冒泡阶段的事件处理机制。<br><a href="http://kingliu-blog.qiniudn.com/images/javascript%20%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A.png" target="_blank" rel="noopener"><img src="http://kingliu-blog.qiniudn.com/images/javascript%20%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A.png" alt="img"></a><br>由于浏览器之间的标准不统一，所以在事件绑定的机制上，一般建议使用冒泡的机制（IE不支持捕获）。</p>
<p>支持冒泡机制的浏览器可以使用 事件委托 ：</p>
<p>事件委托是一种编程技巧，在父级元素监听事件，就可以处理子元素的事件活动，例如一个ul 列表 有 10 个 li 元素，如果给 li 元素都绑定 ‘click’ 事件处理程序的话，就会很麻烦，但是我们只要在 ul元素上绑定 ‘click’ 事件处理程序，使用冒泡方式，就能处理子元素的事件活动。</p>
<p>使用事件代理主要有两个优势：</p>
<ol>
<li>减少事件绑定，提升性能。之前你需要绑定一堆子节点，而现在你只需要绑定一个父节点即可。减少了绑定事件监听函数的数量。</li>
<li>动态变化的 DOM 结构，仍然可以监听。当一个 DOM 动态创建之后，不会带有任何事件监听，除非你重新执行事件监听函数，而使用事件委托监听无须担忧这个问题。</li>
</ol>
<h1 id="javascript-闭包"><a href="#javascript-闭包" class="headerlink" title="javascript-闭包"></a>javascript-闭包</h1><p>今天在看  <a href="http://bonsaiden.github.io/JavaScript-Garden/zh" target="_blank" rel="noopener">javascript 秘密花园</a> 的时候，看到了之前 腾讯笔试的一个笔试的知识点，当时做题的时候没有想清楚，今天看到闭包，总算搞清楚了。</p>
<p>题目是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);  </span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问输出是什么？</p>
<p>当时认为是按照顺许输出 0~9，但是答案是 输出 10 次 10 。</p>
<p>输出 10 次 10 的原因 是，  setTimeout 函数里的 匿名函数保持的是对 i 的引用，由于它是匿名调用，所以这个 i 相当与是 window.i  （浏览器环境中），他是全局对象中的 i 的一个引用。由于 setTimeout 执行 10 次之后，相当与将一个匿名函数加入到任务队列中，在执行完循环之后，调用任务队列中的匿名函数。所以在循环之后，i的值变成了 10 ，所以任务队列中的匿名函数也就打印 10 次 10 。 要依次输出 0~9，就要避免对 i 的引用，可以使用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">console</span>.log(i);  </span><br><span class="line">    &#125;)(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么这样写就能输出 0 ~ 9 呢？ 这里在每一次的循环中创建了一个匿名函数</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lk1ngaa7.github.io/2016/01/25/pdo-with-mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liukai93">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Space of liukai93">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/25/pdo-with-mysql/" itemprop="url">pdo防止注入的原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-25T16:41:47+08:00">
                2016-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当提到防止SQL注入的办法时，脑海中总是会想到使用PDO绑定参数的办法或者使用mysql_real_eascape_string()来处理（虽然古老的 mysql_XXX 这类的函数已经不建议使用）。但是PDO是如何防止注入的呢？</p>
<p>在手册中，有这样一段：</p>
<blockquote>
<h1 id="Prepared-statements-and-stored-procedures"><a href="#Prepared-statements-and-stored-procedures" class="headerlink" title="Prepared statements and stored procedures"></a>Prepared statements and stored procedures</h1><p><strong>Many of the more mature databases support the concept of prepared statements. What are they? They can be thought of as a kind of compiled template for the SQL that an application wants to run, that can be customized using variable parameters. Prepared statements offer two major benefits:</strong></p>
<ul>
<li><strong>The query only needs to be parsed (or prepared) once, but can be executed multiple times with the same or different parameters. When the query is prepared, the database will analyze, compile and optimize it’s plan for executing the query. For complex queries this process can take up enough time that it will noticeably slow down an application if there is a need to repeat the same query many times with different parameters. By using a prepared statement the application avoids repeating the analyze/compile/optimize cycle. This means that prepared statements use fewer resources and thus run faster.</strong></li>
<li><strong>The parameters to prepared statements don’t need to be quoted; the driver automatically handles this. If an application exclusively uses prepared statements, the developer can be sure that no SQL injection will occur (however, if other portions of the query are being built up with unescaped input, SQL injection is still possible).</strong></li>
</ul>
<p><strong>Prepared statements are so useful that they are the only feature that PDO will emulate for drivers that don’t support them. This ensures that an application will be able to use the same data access paradigm regardless of the capabilities of the database.</strong></p>
</blockquote>
<p>大概的翻译是：<br><em>很多更成熟的数据库都支持预处理语句的概念。这些是什么？它可以被认为是作为一种通过编译SQL语句模板来运行sql语句的机制。预处理语句可以带来两大好处：</em></p>
<ul>
<li><ul>
<li><em>查询只需要被解析（或编译）一次，但可以执行多次通过相同或不同的参数。当查询处理好后，数据库将分析，编译和优化它的计划来执行查询。对于复杂的查询这个过程可能需要足够的时间，这将显著地使得应用程序变慢，如果有必要，可以多次使用不同的参数 重复相同的查询。通过使用处理好的语句的应用程序避免重复 【分析/编译/优化】 周期。这意味着，预处理语句使用更少的资源，而且运行得更快。</em></li>
<li>绑定的参数不需要使用引号;该驱动程序会自动处理。如果应用程序使用预处理语句，开发人员可以确保不会发生SQL注入（但是，如果查询的其他部分使用了未转义的输入，SQL注入仍然是可能的）。*</li>
</ul>
</li>
</ul>
<p><em>预处理语句非常有用，PDO可以使用一种本地模拟的办法来为没有预处理功能的数据库系统提供这个功能。这保证了一个应用可以使用统一的访问方式来访问数据库。</em></p>
<p>这里讲了使用PDO可以带来两个很好的效果，预编译带来查询速度的提升，变量的绑定可以预防 sql injection，其实PDO的预防sql注入的机制也是类似于使用 mysql_real_escape_string 进行转义，PDO 有两种转义的机制，第一种是本地转义，这种转义的方式是使用单字节字符集（PHP &lt; 5.3.6）来转义的（<a href="http://blog.csdn.net/leixiaohua1020/article/details/12753723" target="_blank" rel="noopener">单字节与多字节</a>），来对输入进行转义，但是这种转义方式有一些<a href="https://github.com/80vul/phpcodz/blob/master/research/pch-018.md" target="_blank" rel="noopener">隐患</a>。隐患主要是：在PHP版本小于5.3.6的时候，本地转义只能转换单字节的字符集，大于 5.3.6 的版本会根据 PDO 连接中指定的 charset 来转义。PHP官方手册这里有<a href="http://php.net/manual/zh/ref.pdo-mysql.connection.php" target="_blank" rel="noopener">说明</a>：</p>
<blockquote>
<p><strong>Warning</strong></p>
<p>The method in the below example can only be used with character sets that share the same lower 7 bit representation as ASCII, such as ISO-8859-1 and UTF-8. Users using character sets that have different representations (such as UTF-16 or Big5) <em>must</em>use the <em>charset</em> option provided in PHP 5.3.6 and later versions.</p>
</blockquote>
<p>所以就是说，<strong>不同的版本的PDO 在本地转义的行为上是有区别的。</strong></p>
<p>第二种方式是PDO，首先将 sql 语句模板发送给Mysql Server，随后将绑定的字符变量再发送给Mysql server，这里的转义是在Mysql Server做的，它是根据你在连接PDO的时候，在charset里指定的编码格式来转换的。这样的转义方式更健全，同时还可以在又多次重复查询的业务场景下，通过复用模板，来提高程序的性能。如果要设置Mysql Server  来转义的话，就要首先执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);</span><br></pre></td></tr></table></figure>
<p>下面是通过 wireshark 抓到的数据包，来具体显示PDO 查询的过程：<br><a href="http://kingliu-blog.qiniudn.com/images/sql-pdo.png" target="_blank" rel="noopener"><img src="http://kingliu-blog.qiniudn.com/images/sql-pdo.png" alt="img"></a><br>绑定的变量：<br><a href="http://kingliu-blog.qiniudn.com/images/sql-val.png" target="_blank" rel="noopener"><img src="http://kingliu-blog.qiniudn.com/images/sql-val.png" alt="img"></a><br>如果不执行  $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);  PDO 只是会将插入的参数使用本地转义之后和SQL模板拼装起来，然后一起发送给Mysql Server。这实际上与使用mysql_real_escape_string()过滤，然后拼装这种做法并没有什么不同。</p>
<p> 要对数据库的安全做出更加全面的考量，以下两种方式任选其一：</p>
<p>A. 通过添加(php 5.3.6以前版本)：$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);<br>B.  升级到php 5.3.6 (不用设置PDO::ATTR_EMULATE_PREPARES也可以)<br>为了程序移植性和统一安全性，建议使用 $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false) 方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lk1ngaa7.github.io/2016/01/11/websocket-with-php/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liukai93">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Space of liukai93">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/11/websocket-with-php/" itemprop="url">websocket解析和 php 实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-11T21:45:06+08:00">
                2016-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Websocket-协议解析"><a href="#Websocket-协议解析" class="headerlink" title="Websocket 协议解析"></a>Websocket 协议解析</h1><p>​    WebSocket protocol 是HTML5一种新的协议。它是实现了浏览器与服务器全双工通信(full-duplex)。现很多网站为了实现即时通讯，所用的技术都是轮询(polling)。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客服端的浏览器。这种传统的HTTP request 的模式带来很明显的缺点 – 浏览器需要不断的向服务器发出请求，然而HTTP request 的header是非常长的，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽。</p>
<p>​    在 WebSocket API，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送，改变了原有的B/S模式。</p>
<p><a href="https://www.flickr.com/photos/101451303@N08/15831324266" target="_blank" rel="noopener"><img src="https://farm9.staticflickr.com/8598/15831324266_5e16ea3fc1_o.png" alt="server"></a></p>
<p>Websocket 数据：</p>
<p><a href="https://www.flickr.com/photos/101451303@N08/15671127979" target="_blank" rel="noopener"><img src="https://farm8.staticflickr.com/7508/15671127979_acba8f202d_o.png" alt="websocket"></a></p>
<p>浏览器端的websocket 请求一般是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javacsript</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:4000"</span>);</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"succeed"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(“error”);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 new 一个 websocket 对象之后，就会向服务器发送一个 get 请求</p>
<p><a href="https://www.flickr.com/photos/101451303@N08/15857152075" target="_blank" rel="noopener"><img src="https://farm8.staticflickr.com/7525/15857152075_599260fc1e_o.png" alt="request"></a></p>
<p>这个请求是对摸个服务器的端口发送的，一般的话，会预先在服务器将一个socket 绑定到一个端口上，客户端和服务器端在这个预定的端口上通信（我这里绑定的就是 4000 端口，默认情况下，websocke 使用 80 端口）。</p>
<p>然后，在服务器端的socket监听到这个packet 之后就生成一个新的 socket，将发送过来的数据中的 Sec-WebSocket-Key 解析出来，然后按照把“Sec-WebSocket-Ke”加上一个魔幻字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”。使用SHA-1加密，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。</p>
<p>客户端收到这个之后，就会将 通信协议 upgrade 到 websocket 协议。</p>
<p><a href="https://www.flickr.com/photos/101451303@N08/15234859044" target="_blank" rel="noopener"><img src="https://farm8.staticflickr.com/7531/15234859044_8e14d892d8_o.png" alt="response"></a></p>
<p>然后就会在这个持久的通道下进行通信，包括浏览器的询问，服务器的push，双方是在一个全双工的状态下相互通信。 切换后的websocket 协议中的 数据传输帧的格式(此时不再使用html协议) 官方文档给出的说明：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"> +-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line"> |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line"> |I|S|S|S|  (<span class="number">4</span>)  |A|     (<span class="number">7</span>)     |             (<span class="number">16</span>/<span class="number">64</span>)           |</span><br><span class="line"> |N|V|V|V|       |S|             |   (<span class="keyword">if</span> payload len==<span class="number">126</span>/<span class="number">127</span>)   |</span><br><span class="line"> | |<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|       |K|             |                               |</span><br><span class="line"> +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line"> |     Extended payload length continued, <span class="keyword">if</span> payload len == <span class="number">127</span>  |</span><br><span class="line"> + - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line"> |                               |Masking-key, <span class="keyword">if</span> MASK set to <span class="number">1</span>  |</span><br><span class="line"> +-------------------------------+-------------------------------+</span><br><span class="line"> | Masking-key (continued)       |          Payload Data         |</span><br><span class="line"> +-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line"> :                     Payload Data continued ...                :</span><br><span class="line"> + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line"> |                     Payload Data continued ...                |</span><br><span class="line"> +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>直接看这个，谁都会有点头大: 我花了一幅图来简单的解释这个 frame 的结构。</p>
<p><a href="https://www.flickr.com/photos/101451303@N08/15857151995" target="_blank" rel="noopener"><img src="https://farm9.staticflickr.com/8623/15857151995_36a28d62a9_o.png" alt="frame"></a></p>
<p>各字段的解释：</p>
<blockquote>
<p>FIN              1bit 表示信息的最后一帧，flag，也就是标记符</p>
<p>RSV 1-3        1bit each 以后备用的 默认都为 0</p>
<p>Opcode         4bit 帧类型，</p>
<p>Mask              1bit 掩码，是否加密数据，默认必须置为1 </p>
<p>Payload len   7bit 数据的长度，当这个7 bit的数据 == 126 时，后面的2 个字节也是表示数     据长度，当它 == 127 时，后面的 8 个字节表示数据长度Masking-key      1 or 4 bit 掩码Payload data  playload len  bytes 数据</p>
</blockquote>
<p>所以我们这里的代码，通过判断 Playload len的值，来用 substr 截取 Masking-key 和 PlayloadData。</p>
<p>根据掩码解析数据的方法是:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; data.length ; i++)&#123;</span><br><span class="line"></span><br><span class="line">   orginalData += data[i]  ^  maskingKey[i mod <span class="number">4</span>]; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在PHP中，当我们收到数据之后，按照这里的格式截取数据，并将其按照这里的方法解析后就得到了浏览器发送过来的数据。 当我们想把数据发送给浏览器时，也要按照这个格式组装frame。 这里是我的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">frame</span>(<span class="params">$s</span>)</span>&#123;</span><br><span class="line"> 	$a = str_split($s, <span class="number">125</span>);</span><br><span class="line"> 	<span class="keyword">if</span> (count($a) == <span class="number">1</span>)&#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="string">"\x81"</span> . chr(strlen($a[<span class="number">0</span>])) . $a[<span class="number">0</span>];</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	$ns = <span class="string">""</span>;</span><br><span class="line"> 	foreach ($a <span class="keyword">as</span> $o)&#123;</span><br><span class="line"> 		$ns .= <span class="string">"\x81"</span> . chr(strlen($o)) . $o;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> $ns;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>强行将要发送的数据分割成 125 Byte / frame，这样 playload len 只需要 7 bits。也就是直接将数据的长度的ascall码拼接上去，然后后面跟上要发送的数据。 每一个 frame 前面加的 ‘\x81’ 用二进制就是： 1000 0001 1000 ：</p>
<blockquote>
<p>1 是 FIN</p>
<p>000 是三个备用的bit</p>
<p>0001 ： 指的是 opcode 官方的解释：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  |Opcode  | Meaning                             | Reference |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | <span class="number">0</span>      | Continuation Frame                  | RFC <span class="number">6455</span>  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | <span class="number">1</span>      | Text Frame                          | RFC <span class="number">6455</span>  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | <span class="number">2</span>      | Binary Frame                        | RFC <span class="number">6455</span>  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | <span class="number">8</span>      | Connection Close Frame              | RFC <span class="number">6455</span>  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | <span class="number">9</span>      | Ping Frame                          | RFC <span class="number">6455</span>  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | <span class="number">10</span>     | Pong Frame                          | RFC <span class="number">6455</span>  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br></pre></td></tr></table></figure>
<p>可以设置上图中 opcode 的值，来告诉浏览器这个frame的数据属性。</p>
<h1 id="php-实现简单的-websocket-服务端"><a href="#php-实现简单的-websocket-服务端" class="headerlink" title="php 实现简单的 websocket 服务端"></a>php 实现简单的 websocket 服务端</h1><p>自十月底，html5 宣布定稿之后，新一轮的关于html的讨论便开始了，现在这里，我也为大家介绍一种html5标准中提到的新技术 websocket，以及他的 php 实现范例。</p>
<blockquote>
<p><strong>WebSocket</strong>是<a href="http://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>开始提供的一种<a href="http://zh.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">浏览器</a>与<a href="http://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">服务器</a>间进行<a href="http://zh.wikipedia.org/wiki/%E5%85%A8%E9%9B%99%E5%B7%A5" target="_blank" rel="noopener">全双工</a>通讯的网络技术。WebSocket通信协议于2011年被<a href="http://zh.wikipedia.org/wiki/Internet_Engineering_Task_Force" target="_blank" rel="noopener">IETF</a>定为标准<a href="http://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC 6455</a>，WebSocket<a href="http://zh.wikipedia.org/wiki/Application_programming_interface" target="_blank" rel="noopener">API</a>被<a href="http://zh.wikipedia.org/wiki/World_Wide_Web_Consortium" target="_blank" rel="noopener">W3C</a>定为标准。</p>
<p>在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
</blockquote>
<p>传统的web程序，都遵循这样的执行方式，浏览器发送一个请求，然后服务器端接收这个请求，处理完成浏览器的请求之后，再将处理完成的结果返回给浏览器，然后浏览器处理返回的html，将其呈现给用户。如下图所示：</p>
<p><a href="https://www.flickr.com/photos/101451303@N08/15831324266" target="_blank" rel="noopener"><img src="https://farm9.staticflickr.com/8598/15831324266_5e16ea3fc1_o.png" alt="server"></a></p>
<p>即使后来出现了ajax这样的新的技术，它实际也是使用javascript的api来向服务器发送请求，然后等待相应的数据。也就是说，在浏览器和服务器的交互中，我们每想得到一个得到新的数据（更新页面，获得服务器端的最新状态）就必须要发起一个http请求，建立一条TCP/IP链接，当这次请求的数据被浏览器接收到之后，就断开这条TCP/IP连接。</p>
<p>新的websocket技术，在浏览器端发起一条请求之后，服务器端与浏览器端的请求进行握手应答之后，就建立起一条长久的，双工的长连接，基于这条连接，我们不必做一些轮询就能随时获得服务器端的状态，服务器也不必等待浏览器端的请求才能向用户推送数据，可以在这条连接上随时向以建立websocket连接的用户 push 数据。</p>
<p><a href="http://datatracker.ietf.org/doc/rfc6455/?include_text=1" target="_blank" rel="noopener">这里</a>是 websocket 协议的 RFC 文档。</p>
<p>我这里的实现是基于 php sockets的实现，调用了来自 php.net 的 socket-api  <a href="http://php.net/manual/zh/book.sockets.php" target="_blank" rel="noopener">php socket</a> .</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WsServer</span></span>&#123;</span><br><span class="line">      <span class="keyword">public</span>  $socket;</span><br><span class="line">      <span class="keyword">public</span>  $socketArray;</span><br><span class="line">      <span class="keyword">public</span>  $activatedSocketArray;</span><br><span class="line">      <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($address,$port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;socket =  <span class="keyword">$this</span>-&gt;init($address,$port);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;socket == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">($address,$port)</span></span>&#123;</span><br><span class="line">       $wssocket  = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);</span><br><span class="line">     socket_set_option($wssocket, SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>);</span><br><span class="line">     socket_bind($wssocket,$address,$port);</span><br><span class="line">     <span class="keyword">if</span>(socket_listen($wssocket))&#123;</span><br><span class="line">          <span class="keyword">$this</span>-&gt;p(<span class="string">"Socket init success"</span>);</span><br><span class="line">          <span class="keyword">return</span> $wssocket;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">$this</span>-&gt;p(<span class="string">"Socket init failure"</span>);</span><br><span class="line">      <span class="keyword">exit</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">$this</span>-&gt;socketArray[] = <span class="keyword">$this</span>-&gt;socket;</span><br><span class="line">      $write  = <span class="keyword">NULL</span>;</span><br><span class="line">      $except = <span class="keyword">NULL</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="keyword">$this</span>-&gt;activatedSocketArray = <span class="keyword">$this</span>-&gt;socketArray;</span><br><span class="line">      socket_select(<span class="keyword">$this</span>-&gt;activatedSocketArray, $write, $except, <span class="keyword">null</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;activatedSocketArray <span class="keyword">as</span> $s)&#123;</span><br><span class="line">       <span class="keyword">if</span>($s == <span class="keyword">$this</span>-&gt;socket)&#123;</span><br><span class="line">         $client = socket_accept(<span class="keyword">$this</span>-&gt;socket);</span><br><span class="line">         socket_recv($client, $buffer, <span class="number">2048</span>, <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">         <span class="comment">// response a handshake response</span></span><br><span class="line">         <span class="keyword">if</span>(socket_write($client, <span class="keyword">$this</span>-&gt;handshakeResponse($buffer))!== <span class="keyword">false</span>)&#123;</span><br><span class="line">           <span class="keyword">$this</span>-&gt;p(<span class="string">'add a socket into the queue'</span>);</span><br><span class="line">           array_push(<span class="keyword">$this</span>-&gt;socketArray, $client);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">$this</span>-&gt;p(<span class="string">'error on handshake'</span>);</span><br><span class="line">             <span class="keyword">$this</span>-&gt;errorLog(socket_last_error());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        socket_recv($s, $buffer, <span class="number">2048</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        $frame = <span class="keyword">$this</span>-&gt;parseFrame($buffer);</span><br><span class="line">        var_dump($frame);</span><br><span class="line">          $str  = <span class="keyword">$this</span>-&gt;decode($buffer);</span><br><span class="line">          $str = <span class="keyword">$this</span>-&gt;frame($str);</span><br><span class="line">        socket_write($s,$str,strlen($str));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  parse the frame</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">parseFrame</span><span class="params">($d)</span></span>&#123;</span><br><span class="line">      $firstByte = ord(substr($d,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">      $result =<span class="keyword">array</span>();</span><br><span class="line">      $result[<span class="string">'FIN'</span>] = <span class="keyword">$this</span>-&gt;getBit($firstByte,<span class="number">1</span>);</span><br><span class="line">      $result[<span class="string">'opcode'</span>] = $firstByte &amp; <span class="number">15</span>;</span><br><span class="line">      $result[<span class="string">'length'</span>] = ord(substr($d,<span class="number">1</span>,<span class="number">1</span>)) &amp; <span class="number">127</span>;</span><br><span class="line">      <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">getBit</span><span class="params">($m,$n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  ($n &gt;&gt; ($m<span class="number">-1</span>)) &amp; <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   build the data frame sent to client by server socket.  </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">frame</span><span class="params">($s)</span></span>&#123;</span><br><span class="line">      $a = str_split($s, <span class="number">125</span>);</span><br><span class="line">      <span class="keyword">if</span> (count($a) == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\x81"</span> . chr(strlen($a[<span class="number">0</span>])) . $a[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      $ns = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">foreach</span> ($a <span class="keyword">as</span> $o)&#123;</span><br><span class="line">        $ns .= <span class="string">"\x81"</span> . chr(strlen($o)) . $o;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> $ns;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * decode the client socket input </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">decode</span><span class="params">($buffer)</span> </span>&#123;</span><br><span class="line">      $len = $masks = $data = $decoded = <span class="keyword">null</span>;</span><br><span class="line">      $len = ord($buffer[<span class="number">1</span>]) &amp; <span class="number">127</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> ($len === <span class="number">126</span>) &#123;</span><br><span class="line">        $masks = substr($buffer, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        $data = substr($buffer, <span class="number">8</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ($len === <span class="number">127</span>) &#123;</span><br><span class="line">        $masks = substr($buffer, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">        $data = substr($buffer, <span class="number">14</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        $masks = substr($buffer, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        $data = substr($buffer, <span class="number">6</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> ($index = <span class="number">0</span>; $index &lt; strlen($data); $index++) &#123;</span><br><span class="line">        $decoded .= $data[$index] ^ $masks[$index % <span class="number">4</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> $decoded;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * params <span class="doctag">@requestHeaders</span> : read from request socket</span></span><br><span class="line"><span class="comment">   * return an array of request </span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">parseHeaders</span><span class="params">($requsetHeaders)</span></span>&#123;</span><br><span class="line">      $resule =<span class="keyword">array</span>();</span><br><span class="line">      <span class="keyword">if</span> (preg_match(<span class="string">"/GET (.*) HTTP/"</span>              ,$requsetHeaders,$match)) &#123; $resule[<span class="string">'reuqest'</span>] = $match[<span class="number">1</span>]; &#125;</span><br><span class="line">      <span class="keyword">if</span> (preg_match(<span class="string">"/Host: (.*)\r\n/"</span>             ,$requsetHeaders,$match)) &#123; $result[<span class="string">'host'</span>] = $match[<span class="number">1</span>]; &#125;</span><br><span class="line">      <span class="keyword">if</span> (preg_match(<span class="string">"/Origin: (.*)\r\n/"</span>           ,$requsetHeaders,$match)) &#123; $result[<span class="string">'origin'</span>] = $match[<span class="number">1</span>]; &#125;</span><br><span class="line">      <span class="keyword">if</span> (preg_match(<span class="string">"/Sec-WebSocket-Key: (.*)\r\n/"</span>,$requsetHeaders,$match)) &#123; $result[<span class="string">'key'</span>] = $match[<span class="number">1</span>]; &#125;</span><br><span class="line">      <span class="keyword">return</span> $result;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * protocol version : 13</span></span><br><span class="line"><span class="comment">     * generting the key of handshaking</span></span><br><span class="line"><span class="comment">     * return encrypted key</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getKey</span><span class="params">($requestKey)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> base64_encode(sha1($requestKey . <span class="string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span>, <span class="keyword">true</span>));</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**params <span class="doctag">@parseRequest</span> : request written in socket</span></span><br><span class="line"><span class="comment">     * return handshakResponse witten in response socket</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>  <span class="title">handshakeResponse</span><span class="params">($request)</span></span>&#123;</span><br><span class="line">      $parsedRequest  = <span class="keyword">$this</span>-&gt;parseHeaders($request);</span><br><span class="line">      $encryptedKey = <span class="keyword">$this</span>-&gt;getKey($parsedRequest[<span class="string">'key'</span>]);</span><br><span class="line">      $response  = <span class="string">"HTTP/1.1 101 Switching Protocol\r\n"</span> .</span><br><span class="line">          <span class="string">"Upgrade: websocket\r\n"</span> .</span><br><span class="line">          <span class="string">"Connection: Upgrade\r\n"</span> .</span><br><span class="line">          <span class="string">"Sec-WebSocket-Accept: "</span> .$encryptedKey. <span class="string">"\r\n\r\n"</span>;</span><br><span class="line">      <span class="keyword">return</span> $response;</span><br><span class="line">              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * report last_error in socket </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">errorLog</span><span class="params">($ms)</span></span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">'Error:\n'</span>.$ms;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * print the log</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="function"><span class="keyword">function</span> <span class="title">p</span><span class="params">($e)</span></span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> $e.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      $read[] = <span class="keyword">$this</span>-&gt;socket;</span><br><span class="line">      $write = <span class="keyword">null</span>;</span><br><span class="line">      $except = <span class="keyword">null</span>;</span><br><span class="line">      socket_select($read, $write, $except,<span class="keyword">null</span>);</span><br><span class="line">      var_dump($read);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  $w = <span class="keyword">new</span> WsServer(<span class="string">'localhost'</span>,<span class="number">4000</span>);</span><br><span class="line">  $w-&gt;run();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个类主要实现了对websocket的握手回应，将每一个连接成功的websocket加入到一个数组中之后，就能够在服务器端对多个websocket 客户端进行处理。</p>
<p>对websocket的握手请求，在接收到的报文中 会得到一个 Sec-WebSocket-Key 字段，要把“Sec-WebSocket-Key”加上一个魔幻字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”。使用SHA-1加密，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。这样就完成了与客户端之间的握手。</p>
<p>之后，就能在服务器端监听客户端发来的请求了，同时也可以操作在服务端的socket句柄，来向浏览器推送消息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lk1ngaa7.github.io/2016/01/06/php-strsearch-function-investigation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liukai93">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Space of liukai93">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/06/php-strsearch-function-investigation/" itemprop="url">php-字符串搜索函数调研</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-06T19:08:33+08:00">
                2016-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>将一个字符串插入到另外一个字符串中间，是php中常常出现的一个操作，具体的实现方案也有替换和直接插入两种，涉及到的相关函数也不少，下面就是我在一个实际工作当中处理字符串插入的效率的调研。</p>
<h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>在一个 1MB左右的文本文件(content)中的 “hello” 前插入一个10个字节大小的字符串(string)。</p>
<h3 id="采取的方案：（机器性能不同，用相对的比较方式对比性能）"><a href="#采取的方案：（机器性能不同，用相对的比较方式对比性能）" class="headerlink" title="采取的方案：（机器性能不同，用相对的比较方式对比性能）"></a>采取的方案：（机器性能不同，用相对的比较方式对比性能）</h3><table>
<thead>
<tr>
<th>编号</th>
<th>方式</th>
<th>性能(此处是相对值，仅表示各函数的相对速度大小)</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>【替换】str_replace(‘#hello#’,$string,$content)</td>
<td>3</td>
<td>备注</td>
</tr>
<tr>
<td>B</td>
<td>【替换】strtr($content,array(”=&gt;$script));</td>
<td>42</td>
<td>备注</td>
</tr>
<tr>
<td>C</td>
<td>【正则替换】preg_replace(‘##hello##’,$script,$content);</td>
<td>4.4</td>
<td>备注</td>
</tr>
<tr>
<td>D</td>
<td>【Substr_replace +strops 插入】substr_replace($content,$script,strpos($content,”),0)</td>
<td>1</td>
<td>备注</td>
</tr>
</tbody>
</table>
<h3 id="A-方案-str-replace-函数"><a href="#A-方案-str-replace-函数" class="headerlink" title="A 方案 str_replace() 函数"></a>A 方案 str_replace() 函数</h3><p>函数签名：</p>
<blockquote>
<p><a href="http://php.net/manual/en/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <strong>str_replace</strong> ( <a href="http://php.net/manual/en/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$search</code> , <a href="http://php.net/manual/en/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$replace</code> , <a href="http://php.net/manual/en/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$subject</code> [, int <code>&amp;$count</code> ] )</p>
<p>参数<br>如果 search 和 replace 为数组，那么 str_replace() 将对 subject 做二者的映射替换。如果 replace 的值的个数少于 search 的个数，多余的替换将使用空字符串来进行。如果 search 是一个数组而 replace 是一个字符串，那么 search 中每个元素的替换将始终使用这个字符串。该转换不会改变大小写。</p>
<p>如果 search 和 replace 都是数组，它们的值将会被依次处理。</p>
<p>search<br>查找的目标值，也就是 needle。一个数组可以指定多个目标。<br>replace<br>search 的替换值。一个数组可以被用来指定多重替换。<br>subject<br>执行替换的数组或者字符串。也就是 haystack。</p>
<p>如果 subject 是一个数组，替换操作将遍历整个 subject，返回值也将是一个数组。<br>count<br>如果被指定，它的值将被设置为替换发生的次数。<br>返回值 ¶<br>该函数返回替换后的数组或者字符串。</p>
</blockquote>
<p>输入的类型可以是字符串或者数组，先对字符串进行分析</p>
<p>情况1．输入的 search 和 replace 均为字符串</p>
<ol>
<li>替换的过程首先要查找 search ，在一个字符串中查找另外一个字符串，就变成了经典的 ‘find needls in haystack’ 问题了。<br>在源码中，调用情况是 str_replace-&gt;php_str_to_str_ex[字符串替换]-&gt;zend_memstr php_str_to_str_ex在 ext/standerd/string.c 的<a href="http://lxr.php.net/xref/PHP_5_3/ext/standard/string.c#php_str_to_str_ex" target="_blank" rel="noopener">php_str_to_str_ex</a> 顾名思义，他就是主要负责处理字符串替换，而 zend_memstr 主要是查找 needles</li>
</ol>
<p>zend_memstr 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> *</span><br><span class="line">zend_memnstr(<span class="keyword">char</span> *haystack, <span class="keyword">char</span> *needle, <span class="keyword">int</span> needle_len, <span class="keyword">char</span> *end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = haystack;</span><br><span class="line">    <span class="keyword">char</span> ne = needle[needle_len<span class="number">-1</span>];</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (needle_len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span> *)<span class="built_in">memchr</span>(p, *needle, (end-p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needle_len &gt; end-haystack) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end -= needle_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &lt;= end) &#123;</span><br><span class="line">      <span class="comment">// 如果在 p 指向的前(end - p +1)个空间查找到 needle 的首字符，便比较needle的最后一个字符和 p 当前指向的位置 + needle_len 个字符;</span></span><br><span class="line">      <span class="comment">// 这个算法在 needle的第一个字符不会密集出现在 haystack 中时，会比较高效，memchr 会带来较大的 移动步长，相比于 KMP，Horspol 算法，简单，易懂</span></span><br><span class="line">      <span class="keyword">if</span> ((p = (<span class="keyword">char</span> *)<span class="built_in">memchr</span>(p, *needle, (end-p+<span class="number">1</span>))) &amp;&amp; ne == p[needle_len<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(needle, p, needle_len<span class="number">-1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用 zend_memstr 查找到 search 的内存地址之后，php_str_to_str_ex 就会使用memcpy ，用 to 来替换 from。</p>
<p>【值得注意的是，在php_str_to_str_ex 中，会一直查找 subject 中的 search ，知道把他们全部替换为 replace】也就是说，这个过程在发生一次之后不会退出，直到循环，将所有 content 里的 to 替换成 from 才会退出。</p>
<p>当 str_replace 输入为数组时，使用的算法和 输入为 string 是一样的，只不过相当于循环的处理输入的数组，将他们单个取出，像对待字符串一样去处理。</p>
<h3 id="方案B-strtr-函数"><a href="#方案B-strtr-函数" class="headerlink" title="方案B strtr() 函数"></a>方案B strtr() 函数</h3><blockquote>
<h3 id="说明-¶"><a href="#说明-¶" class="headerlink" title="说明 ¶"></a>说明<a href="http://php.net/manual/zh/function.strtr.php#refsect1-function.strtr-description" target="_blank" rel="noopener"> ¶</a></h3><p>string <strong>strtr</strong> ( string <code>$str</code> , string <code>$from</code> , string <code>$to</code> )</p>
<p>string <strong>strtr</strong> ( string <code>$str</code> , array <code>$replace_pairs</code> )</p>
<p>该函数返回 <code>str</code> 的一个副本，并将在 <code>from</code> 中指定的字符转换为 <code>to</code> 中相应的字符。 比如， <em>$from[$n]</em>中每次的出现都会被替换为 <em>$to[$n]</em>，其中 <em>$n</em> 是两个参数都有效的位移(offset)。</p>
<p>如果 <code>from</code> 与 <code>to</code> 长度不相等，那么多余的字符部分将被忽略。 <code>str</code> 的长度将会和返回的值一样。</p>
<p>参数<a href="http://php.net/manual/zh/function.strtr.php#refsect1-function.strtr-parameters" target="_blank" rel="noopener"> ¶</a></p>
</blockquote>
<blockquote>
<ul>
<li><p><code>str</code></p>
<p>待转换的字符串</p>
</li>
<li><p><code>from</code></p>
<p>字符串中与将要被转换的目的字符 <code>to</code> 相对应的源字符</p>
</li>
<li><p><code>to</code></p>
<p>字符串中与将要被转换的字符 <code>from</code> 相对应的目的字符</p>
</li>
<li><p><code>replace_pairs</code></p>
<p>参数 <code>replace_pairs</code> 可以用来取代 <code>to</code> 和 <code>from</code> 参数，因为它是以 <em>array(‘from’ =&gt; ‘to’, …)</em> 格式出现的数组。</p>
</li>
</ul>
<h3 id="返回值-¶"><a href="#返回值-¶" class="headerlink" title="返回值 ¶"></a>返回值<a href="http://php.net/manual/zh/function.strtr.php#refsect1-function.strtr-returnvalues" target="_blank" rel="noopener"> ¶</a></h3><p>返回转换后的字符串。</p>
<p>如果 <code>replace_pairs</code> 中包含一个空字符串（<em>“”</em>）键，那么将返回 <strong>FALSE</strong>。 If the <code>str</code> is not a scalar then it is not typecasted into a string, instead a warning is raised and <strong>NULL</strong>is returned.</p>
</blockquote>
<p>strtr 有两种输入情况，源码中也是将它分成了两个子过程来处理：</p>
<p>输入为字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PHPAPI <span class="keyword">char</span> *<span class="title">php_strtr</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> len, <span class="keyword">char</span> *str_from, <span class="keyword">char</span> *str_to, <span class="keyword">int</span> trlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> xlat[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((trlen &lt; <span class="number">1</span>) || (len &lt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个 256 大小的数组,代表 ascll 码</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; xlat[i] = i, i++);</span><br><span class="line">    <span class="comment">// 用 to 来替换指定的from字符的 ascll</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; trlen; i++) &#123;</span><br><span class="line">        xlat[(<span class="keyword">unsigned</span> <span class="keyword">char</span>) str_from[i]] = str_to[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新赋值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        str[i] = xlat[(<span class="keyword">unsigned</span> <span class="keyword">char</span>) str[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入为数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &#123;&#123;&#123; php_strtr_array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_strtr_array</span><span class="params">(zval *return_value, <span class="keyword">char</span> *str, <span class="keyword">int</span> slen, HashTable *hash)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zval **entry;</span><br><span class="line">    <span class="keyword">char</span>  *string_key;</span><br><span class="line">    uint   string_key_len;</span><br><span class="line">    zval **trans;</span><br><span class="line">    zval   ctmp;</span><br><span class="line">    ulong num_key;</span><br><span class="line">    <span class="keyword">int</span> minlen = <span class="number">128</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>, pos, len, found;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    HashPosition hpos;</span><br><span class="line">    smart_str result = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    HashTable tmp_hash;</span><br><span class="line"></span><br><span class="line">    zend_hash_init(&amp;tmp_hash, zend_hash_num_elements(hash), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    zend_hash_internal_pointer_reset_ex(hash, &amp;hpos);</span><br><span class="line">    <span class="keyword">while</span> (zend_hash_get_current_data_ex(hash, (<span class="keyword">void</span> **)&amp;entry, &amp;hpos) == SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (zend_hash_get_current_key_ex(hash, &amp;string_key, &amp;string_key_len, &amp;num_key, <span class="number">0</span>, &amp;hpos)) &#123;</span><br><span class="line">            <span class="keyword">case</span> HASH_KEY_IS_STRING:</span><br><span class="line">                len = string_key_len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (len &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    zend_hash_destroy(&amp;tmp_hash);</span><br><span class="line">                    RETURN_FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">                zend_hash_add(&amp;tmp_hash, string_key, string_key_len, entry, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; maxlen) &#123;</span><br><span class="line">                    maxlen = len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &lt; minlen) &#123;</span><br><span class="line">                    minlen = len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> HASH_KEY_IS_LONG:</span><br><span class="line">                Z_TYPE(ctmp) = IS_LONG;</span><br><span class="line">                Z_LVAL(ctmp) = num_key;</span><br><span class="line"></span><br><span class="line">                convert_to_string(&amp;ctmp);</span><br><span class="line">                len = Z_STRLEN(ctmp);</span><br><span class="line">                zend_hash_add(&amp;tmp_hash, Z_STRVAL(ctmp), len+<span class="number">1</span>, entry, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">                zval_dtor(&amp;ctmp);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (len &gt; maxlen) &#123;</span><br><span class="line">                    maxlen = len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &lt; minlen) &#123;</span><br><span class="line">                    minlen = len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zend_hash_move_forward_ex(hash, &amp;hpos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key = emalloc(maxlen+<span class="number">1</span>);</span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 替换的步骤在这里</span></span><br><span class="line">    <span class="keyword">while</span> (pos &lt; slen) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pos + maxlen) &gt; slen) &#123;</span><br><span class="line">            maxlen = slen - pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// key 是每一次需要被替换的字符串</span></span><br><span class="line">        <span class="built_in">memcpy</span>(key, str+pos, maxlen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (len = maxlen; len &gt;= minlen; len--) &#123;</span><br><span class="line">            key[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// trans 被赋值为新的字符串</span></span><br><span class="line">            <span class="keyword">if</span> (zend_hash_find(&amp;tmp_hash, key, len+<span class="number">1</span>, (<span class="keyword">void</span>**)&amp;trans) == SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">char</span> *tval;</span><br><span class="line">                <span class="keyword">int</span> tlen;</span><br><span class="line">                zval tmp;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Z_TYPE_PP(trans) != IS_STRING) &#123;</span><br><span class="line">                    tmp = **trans;</span><br><span class="line">                    zval_copy_ctor(&amp;tmp);</span><br><span class="line">                    convert_to_string(&amp;tmp);</span><br><span class="line">                    tval = Z_STRVAL(tmp);</span><br><span class="line">                    tlen = Z_STRLEN(tmp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tval = Z_STRVAL_PP(trans);</span><br><span class="line">                    tlen = Z_STRLEN_PP(trans);</span><br><span class="line">                &#125;</span><br><span class="line">      <span class="comment">// 将 trans 附加到一个新的字符串，最终用来被返回</span></span><br><span class="line">                smart_str_appendl(&amp;result, tval, tlen);</span><br><span class="line">                pos += len;</span><br><span class="line">                found = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Z_TYPE_PP(trans) != IS_STRING) &#123;</span><br><span class="line">                    zval_dtor(&amp;tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! found) &#123;</span><br><span class="line">            smart_str_appendc(&amp;result, str[pos++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    efree(key);</span><br><span class="line">    zend_hash_destroy(&amp;tmp_hash);</span><br><span class="line">    smart_str_0(&amp;result);</span><br><span class="line">    RETVAL_STRINGL(result.c, result.len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 strtr 的执行过程来看，strtr 也是需要遍历整个 subject 来替换 to -&gt; from，这个也是它在我们的场景中他的效率比较慢的原因。</p>
<h3 id="方案C-正则替换"><a href="#方案C-正则替换" class="headerlink" title="方案C 正则替换"></a>方案C 正则替换</h3><p>正则替换涉及到正则解析引擎，这个应该也是需要遍历 subject 来替换 to -&gt; from。</p>
<h3 id="方案D-substr-replace-strops-插入"><a href="#方案D-substr-replace-strops-插入" class="headerlink" title="方案D substr_replace +strops 插入"></a>方案D substr_replace +strops 插入</h3><p>substr_replace 函数签名：</p>
<blockquote>
<p><a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <strong>substr_replace</strong> ( <a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$string</code> , <a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$replacement</code> , <a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$start</code> [, <a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a><code>$length</code> ] )</p>
<p><strong>substr_replace()</strong> 在字符串 <code>string</code> 的副本中将由 <code>start</code> 和可选的 <code>length</code> 参数限定的子字符串使用 <code>replacement</code>进行替换。</p>
</blockquote>
<p>strpos 函数签名：</p>
<blockquote>
<h3 id="说明-¶-1"><a href="#说明-¶-1" class="headerlink" title="说明 ¶"></a>说明<a href="http://php.net/manual/zh/function.strpos.php#refsect1-function.strpos-description" target="_blank" rel="noopener"> ¶</a></h3><p><a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <strong>strpos</strong> ( string <code>$haystack</code> , <a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$needle</code> [, int <code>$offset</code> = 0 ] )</p>
<p>返回 <code>needle</code> 在 <code>haystack</code> 中首次出现的数字位置。</p>
</blockquote>
<p>使用 strpos 定位目标串位置，然后 substr_replace 快速替换。strpos 使用上面提到的 zend_memstr 查找 needle，然后 substr_replace 替换，替换的核心操作就是涉及到内存的分配。这个方法，只是会在目标串中查找一次needle，相比之前的方法，减少了目标串的遍历，由于我们的目标串较大，所以这个方法在相对的比较中，占据了较大的优势.</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>在网上搜索字符串替换方案时，会有各种五花八门的解释和分析，但是都缺少原理上的分析和具体场景。在这次调研过程中，我也发现php在一个问题的解决上，有较多的解决办法，看似相同，却又有区别，这个就要对源码较清晰的了解方法的执行过程，才能写出较好性能的程序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lk1ngaa7.github.io/2015/11/25/mysql-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liukai93">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Space of liukai93">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/25/mysql-notes/" itemprop="url">mysql使用中的积累</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-25T18:07:33+08:00">
                2015-11-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql-外键"><a href="#mysql-外键" class="headerlink" title="mysql-外键"></a>mysql-外键</h1><p>mysql 外键在我个人的理解中是一个 DB 级别的提供数据一致性保障的工具。</p>
<ol>
<li>实体完整性：</li>
</ol>
<p>实体完整性(Entity integrity)是指关系的主关键字不能重复也不能取”空值”。一个关系对应现实世界中一个实体集。现实世界中的实体是可以相互区分、识别的，也即它们应具有某种惟一性标识。在<a href="http://baike.baidu.com/view/68347.htm" target="_blank" rel="noopener">关系模式</a>中，以主关键字作为惟一性标识，而主关键字中的属性(称为主属性)不能取空值，否则，表明关系模式中存在着不可标识的实体(因空值是”不确定\”的)，这与现实世界的实际情况相矛盾，这样的实体就不是一个完整实体。按<a href="http://baike.baidu.com/view/5556962.htm" target="_blank" rel="noopener">实体完整性规则</a>要求，主属性不得取空值，如主关键字是多个属性的组合，则所有主属性均不得取空值。</p>
<ol>
<li>参照完整性：</li>
</ol>
<p>参照完整性(Referential Iintigrity)是定义建立关系之间联系的主关键字与外部关键字引用的约束条件。关系数据库中通常都包含多个存在相互联系的关系，关系与关系之间的联系是通过公共属性来实现的。所谓公共属性，它是一个关系R(称为被参照关系或目标关系)的主关键字，同时又是另一关系K(称为参照关系)的外部关键字。如果参照关系K中外部关键字的取值，要么与被参照关系R中某元组主关键字的值相同，要么取空值，那么，在这两个关系间建立关联的主关键字和外部关键字引用，符合参照完整性规则要求。如果参照关系K的外部关键字也是其主关键字，根据实体完整性要求，主关键字不得取空值，因此，参照关系K外部关键字的取值实际上只能取相应被参照关系R中已经存在的主关键字值。</p>
<ol>
<li>用户定义完整性：</li>
</ol>
<p>实体完整性和参照完整性适用于任何关系型数据库系统，它主要是针对关系的主关键字和外部关键字取值必须有效而做出的约束。用户定义完整性(user defined integrity)则是根据应用环境的要求和实际的需要，对某一具体应用所涉及的数据提出约束性条件。这一约束机制一般不应由应用程序提供，而应有由关系模型提供定义并检验，用户定义完整性主要包括字段有效性约束和记录有效性。</p>
<p>外键就是在数据库中参照完整性的具体实现。</p>
<p>外键的定义：一个属性不是他所在关系的主键，但却是另外一个关系的主键。</p>
<h2 id="mysql-中建立外键"><a href="#mysql-中建立外键" class="headerlink" title="mysql 中建立外键"></a>mysql 中建立外键</h2><p>在mysql数据库中有innodb engine 支持的不同表中是可以建立外键的，建立外键的表必须满足这几个条件：</p>
<ol>
<li>两张表必须都是InnoDB表，并且它们没有临时表。</li>
<li>建立外键关系的对应列必须具有相似的InnoDB内部数据类型。</li>
<li>建立外键关系的对应列必须建立了索引。(在可视化工具会自动建立)</li>
</ol>
<p>现在有两个表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `order` (</span><br><span class="line">  `user_id` int(11) NOT NULL,</span><br><span class="line">  `order_id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(100) CHARACTER SET utf8 NOT NULL,</span><br><span class="line">  PRIMARY KEY (`order_id`),</span><br><span class="line">  KEY `order_user` (`user_id`),</span><br><span class="line">  CONSTRAINT `order_user` FOREIGN KEY (`user_id`) REFERENCES `user` (`user_id`) ON DELETE  CASCADE ON UPDATE CASCADE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `user_id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(50) CHARACTER SET utf8 NOT NULL,</span><br><span class="line">  PRIMARY KEY (`user_id`),</span><br><span class="line">  KEY `name` (`name`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1;</span><br></pre></td></tr></table></figure>
<p>在order 表中有一个外键，此时 user 表是主表，order 是子表。(主表：外键中主键所在的表。子表：外建中非主键的属性所在的表)</p>
<p>建立外键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT `order_user` FOREIGN KEY (`user_id`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE CASCADE</span><br></pre></td></tr></table></figure></p>
<p>执行上面的语句后，此时在 user 和 order 建立了一种关系，当你没有把 order 中的 user_id 的属性设置为NULL时 此时 order 中的 每一行数据中的 user_id 的值只能是 user 表的 user_id的<br>子集 。例如:如果 order.user_id = {1,2,3} 则 order.user_id 在插入数据的时候只能选择 1,2,3 这三个值。当子表试图插入一个在主表中对应的外键不存在的值时，子表会拒绝插入。</p>
<p>新建外键是可以选择这5个选线 DELETE CASCADE ON UPDATE CASCADE 当主表更新或删除存在于外键关系中的主键时，子表应该采取的动作，当然也可以不添加。此时共有5*5+1 种动作</p>
<ol>
<li>CASCADE: 从父表中删除或更新对应的行，同时自动的删除或更新自表中匹配的行。ON DELETE CANSCADE和ON UPDATE CANSCADE都被InnoDB所支持。</li>
<li>SET NULL: 从父表中删除或更新对应的行，同时将子表中的外键列设为空。注意，这些在外键列没有被设为NOT NULL时才有效。ON DELETE SET NULL和ON UPDATE SET SET NULL都被InnoDB所支持。</li>
<li>NO ACTION: InnoDB拒绝删除或者更新父表。</li>
<li>RESTRICT: 拒绝删除或者更新父表。指定RESTRICT（或者NO ACTION）和忽略ON DELETE或者ON UPDATE选项的效果是一样的。</li>
<li>SET DEFAULT: InnoDB目前不支持。</li>
</ol>
<p>这里所指的更新或删除子表指的是只对外键关系中的属性起作用。</p>
<h2 id="mysql-外键使用场景"><a href="#mysql-外键使用场景" class="headerlink" title="mysql 外键使用场景"></a>mysql 外键使用场景</h2><p>外键约束是满足 数据库参照完整性的</p>
<p>参照完整性(Referential Iintigrity)是定义建立关系之间联系的主关键字与外部关键字引用的约束条件。</p>
<p>来假设一个情况：一个购物网站的数据库有这两张表(当然不止两张) user 和 order (订单)</p>
<p>mysql 建表语句如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `order` (</span><br><span class="line">  `user_id` int(11) NOT NULL,</span><br><span class="line">  `order_id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(100) CHARACTER SET utf8 NOT NULL,</span><br><span class="line">  PRIMARY KEY (`order_id`),</span><br><span class="line">  KEY `order_user` (`user_id`),</span><br><span class="line">  CONSTRAINT `order_user` FOREIGN KEY (`user_id`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE CASCADE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `user_id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(50) CHARACTER SET utf8 NOT NULL,</span><br><span class="line">  PRIMARY KEY (`user_id`),</span><br><span class="line">  KEY `name` (`name`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1;</span><br></pre></td></tr></table></figure>
<p>在order 中每一条订单都属于一位用户 ，用户在order 表中拥有多条记录，此时在order 中表中不可能出现一条记录的user_id 不在user的 user_id 的记录，如果这条记录的拥有者没有</p>
<p>存在与我的user 表中，它就不是我的用户，所以order 中不可能存在他的记录。这是一个很简单逻辑。在应用程序层次可以用一些不简单的代码实现。但是 有没有想过 如果你有数十个表每个表与其他表都有上述 user和order 这样的关系，你还能够驾驭他们在代码间的关系吗？当你的网站的程序员跳槽后，你能保证你新聘请的程序员不会对着这复杂和晦涩的逻辑嘶吼吗？</p>
<p>在这种情况下，在数据库层次添加外键约束，用一个统一的标准来表达上述的关系可以更加的有利于代码的维护和更新。</p>
<p>在 order 表中 我们可以添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CONSTRAINT `order_user` FOREIGN KEY (`user_id`) REFERENCES `user` (`user_id`) ONDELETE CASCADE ON UPDATE CASCADE</span><br></pre></td></tr></table></figure></p>
<p>这样，在order 中和就不能添加user 中 user_id 不存在的值了，也就保证了order 和 user的 参照完整性<br><strong> ON DELETE CASCADE ON UPDATE CASCADE </strong>  指的是在主表也就是 user 表的user_id 发生update 或delete 时，子表order 的 user_id 发生update user_id那一行数据 delete，这里还有其他的一些动作。</p>
<p>使用外键约束，不但简化了业务逻辑 还是一层对数据的完整性的保护 ，你一定不会想在你的order表中出现一条莫名其妙的订单吧，外键约束也在某种程度上保护了数据。在一些对数据一致性要求比较高的场景中，我们可以借助 DB 的外键来避免业务逻辑上的疏漏。</p>
<h1 id="mysql-索引"><a href="#mysql-索引" class="headerlink" title="mysql-索引"></a>mysql-索引</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lk1ngaa7.github.io/2015/01/11/character-encode-in-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liukai93">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Space of liukai93">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/01/11/character-encode-in-programming/" itemprop="url">字符集和字符编码学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-11T21:34:17+08:00">
                2015-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在web开发中我们总会遇到这样那样的字符编码问题，例如，当我们在代码编辑器里可以好好显示的html文档在浏览器里却变成了乱码，有时候为了能让我们的页面正常显示我们可能要忙上一天都无法解决（我可是深有体会）。为了搞清楚字符编码的问题，今天我也花了很长时间去百度。这里我和大家分享一下我的感想，不对之处，欢迎指正。</p>
<p>​    首先要了解下什么是字符编码和字符集。</p>
<p><strong>字符集（Charset）</strong>：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p>
<p>字符集的概念就是指一个集合，例如：26个英文字母就构成了一个英文字母字符集，还有繁体汉字字符集、日文汉字字符集等。</p>
<p> <strong>字符编码（Character Encoding）</strong>：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。</p>
<p>字符编码指一套规则，计算机只能处理由0,1构成的数据，计算机不能处理符号和字符，他只会处理0,1数据。为了能让计算机处理这些非数值数据，我们就把非数值数据根据一定的规则与一些二进制数据对应起来，例如在ASCLL编码中，我们用’0110 0001’来表示’a’, <a href="http://blog.csdn.net/macky0668/article/details/3958822" target="_blank" rel="noopener">ASCLL对应表</a> , 大家可以去看看。总而言之，这些将字符集里的字符与二进制数据对应的法则的集合就是字符编码。</p>
<p>所以，一个字符集必然对应着一个一个字符编码。</p>
<p>常见的字符集&amp;字符编码。</p>
<p><strong>ASCLL字符集&amp;字符编码。</strong></p>
<p><strong>ASCII</strong>（<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，<strong>美国信息交换标准代码</strong>））是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以勉强显示其他西欧语言。它是现今最通用的单字节编码系统（但是有被Unicode追上的迹象），并等同于国际标准ISO/IEC 646。<strong>ASCII**</strong>字符集**：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p>
<p><strong>ASCII**</strong>编码**：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位二进制（一个字节）表示一个字符，共128字符。后来，随这计算机的普及128个字符不够用了，于是就动用了剩下的哪一个二进制，形成了扩展的ASCLL编码，共有256个。</p>
<p>128的ASCLL编码表</p>
<p><img src="http://farm8.staticflickr.com/7423/9756323335_801fe0ec04_o.png" alt="img"></p>
<p>256的ASCLL编码表。</p>
<p><img src="http://farm4.staticflickr.com/3807/9756121812_9c9c265d10_o.png" alt="img"></p>
<p>ASCLL相对来说是一种比较古老的字符集&amp;字符编码，因为他表示的字符太少了，渐渐就产生了其他包含更多字符的字符集&amp;字符编码。</p>
<p><strong>GBXXXX字符集&amp;编码</strong></p>
<p><strong>BG—-国标</strong></p>
<p><strong>GB 2312 **</strong>字符集&amp;编码**</p>
<p><strong>GB 2312 **</strong>字符集：**</p>
<p>GB 2312 或 GB 2312-80 是中国国家标准<a href="http://baike.baidu.com/view/79493.htm" target="_blank" rel="noopener">简体中文</a><a href="http://baike.baidu.com/view/51987.htm" target="_blank" rel="noopener">字符集</a>，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，<a href="http://baike.baidu.com/view/286311.htm" target="_blank" rel="noopener">1981年</a><a href="http://baike.baidu.com/view/164971.htm" target="_blank" rel="noopener">5月1日实施。GB2312编码通行于</a><a href="http://baike.baidu.com/view/327945.htm" target="_blank" rel="noopener">中国大陆</a>；<a href="http://baike.baidu.com/view/3593.htm" target="_blank" rel="noopener">新加坡</a>等地也采用此编码。中国大陆几乎所有的中文系统和国际化的<a href="http://baike.baidu.com/view/37.htm" target="_blank" rel="noopener">软件</a>都支持GB 2312。</p>
<p><strong>GB 2312字符编码：</strong></p>
<p>一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7（176–247），后面一个字节（低字节）从0xA1到0xFE（160–254），这样我们就可以组合出大约6654多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p>
<p>GB2312字符集中删掉了扩展后的那部分ASCLL字符,也就是说一个字符的二进制大于127是没有在GB2312中定义的。GB2312 收录了%99的常用汉字，但对于一些偏僻的姓，少数名族的字符没有收录，这时候就有必要出现另一种扩充的编码方式，这就是GBK。</p>
<p><strong>GBK**</strong>字符集&amp;编码**</p>
<p><strong>GBK**</strong>字符集<em>**： </em>gbk字符集是GB2312的超集，同 GB2312一样，GBK也支持希腊字母、日文假名字母、俄语字母等字符，但不支持韩语中的表音字符（非汉字字符）。GBK还收录了GB2312不包含的 汉字部首符号、竖排标点符号等字符。</p>
<p><strong>GBK字符编码：</strong>为了能够表示更多的字符，GBK的制定者们扩充了表示字符的字节范围，规定：一个小于127的字符的意义与原来相同，当有一个大于127的字符出现时且这个大于127的字符的后面跟着一个字节范围是0x40-7E和0x80-0xFE（十进制：64—127和128—256）时，他就表示一个汉字，也就是说高<a href="http://baike.baidu.com/view/60408.htm" target="_blank" rel="noopener">字节</a>范围是0×81-0xFE，低字节范围是0x40-7E和0x80-0xFE。从这一点可以看出，GBK完全兼容了GB2312，而他又进行了扩展，但这个扩展对程序员们造成了一些影响。在GBK中，当我们遍历一个字符串时，我们无法通过判断他的二进制码是否小于127来判断他是有特殊含义的ASCLL字符，因为他有可能是一个汉字的一半。所以，当我们想要在字符串中添加标识符时，我们最好选择小于64的字符来做，例如（!,@,#,$,%,^）.</p>
<p>有些系统中用0x40-0x7E中的字符（如”|”）做特殊符号，在定位这些符号时又没有判断这些符号是不是属于某个 GBK字符的低字节，这样就会造成错误判断。在支持GB2312的环境下就不存在这个问题。需要注意的是支持GBK的环境中小于0x80的某个字节未必就 是ASCII符号；另外就是最好选用小于0×40的ASCII符号做一些特殊符号，这样就可以快速定位，且不用担心是某个汉字的另一半。Big5编码中也存在相应问题。</p>
<p><strong>GB13080**</strong>字符集&amp;编码**</p>
<p><strong>GB13080字符集：</strong>全称：国家标准GB 18030-2005《信息技术 中文编码字符集》，是中华人民共和国现时最新的内码字集，是GB 18030-2000《信息技术 信息交换用汉字编码字符集 基本集的扩充》的修订版。与GB 2312-1980完全兼容，与GBK基本兼容，支持GB 13000及Unicode的全部统一汉字，共收录汉字70244个。</p>
<p><strong>GB13080字符编码：</strong>GBK和GB2312都是双<a href="http://baike.baidu.com/view/60408.htm" target="_blank" rel="noopener">字节</a>等宽编码，如果算上和ASCII兼容所支持的单<a href="http://baike.baidu.com/view/60408.htm" target="_blank" rel="noopener">字节</a>，也可以理解为是单字节和双字节混合的<a href="http://baike.baidu.com/view/1486307.htm" target="_blank" rel="noopener">变长编码</a>。GB18030编码是<a href="http://baike.baidu.com/view/1486307.htm" target="_blank" rel="noopener">变长编码</a>，有单字节、双字节和四字节三种方式。GB18030的单字节编码范围是0x00-0x7F，完全等同与ASCII；双字节编码的范围和GBK相同，高字节是0x81-0xFE，低字节 的编码范围是0x40-0x7E和0x80-FE；四字节编码中第一、三字节的编码范围是0x81-0xFE，二、四字节是0x30-0x39。</p>
<p><strong>BIG5字符集&amp;编码</strong></p>
<p><strong>BIG5字符集：</strong>由于GB系列的字符集&amp;字符编码只收录了简体汉字而没有考虑台湾人民的感受，所以他们也推出了自己的字符集&amp;字符编码那就是大五码—BIG5，Big5收录的汉字只包括繁体汉字，不包括<a href="http://baike.baidu.com/view/2691330.htm" target="_blank" rel="noopener">简体汉字</a>，一些生僻的汉字也没有收录。GBK收录的日文假名<a href="http://baike.baidu.com/view/263416.htm" target="_blank" rel="noopener">字符</a>、俄文字符BIG5也没有收录。Big5编码对应的字符集是GBK字符集的子集，也就是说Big5收录的字符是GBK收录字符的一部分，但相同字符的编码不同。</p>
<p><strong>BIG5字符编码：</strong>Big5是双<a href="http://baike.baidu.com/view/60408.htm" target="_blank" rel="noopener">字节</a>编码，高字节编码范围是0x81-0xFE（128–255），低字节编码范围是0x40-0x7E和0xA1-0xFE。和GBK相比，少了低<a href="http://baike.baidu.com/view/60408.htm" target="_blank" rel="noopener">字节</a>是0x80-0xA0的组合。0x8140-0xA0FE是保留区域，用于用户造字区。</p>
<p>因为Big5也占用了ASCII的编码空间（低字节所使用的0x40-0x7E），所以Big5编码在一些环境下存在和GBK编码相同的问题，即低字节范围为0x40-0x7E的字符有可能会被误处理，尤其是低字节是0x5C（”/”）和0x7C（”|”）的字符。可以参考GBK一节相应说明。</p>
<blockquote>
<p><strong>小结：</strong>在上述所例举的GB系列，BIG5，这些字符集他们都用一个小于127的字节来表示英文字符，用两个字节且第一个字节必须大于127的双字节来表示汉字。于是他们有了一个共同的名字—- “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。</p>
<p>伟大的UNICODE</p>
</blockquote>
<p>　因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用 着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案。导致文件在不同的地区的传输出现了很大的问题，这时候一个伟大的创想产生了——Unicode（”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”）。这个由一个叫 ISO（国际标谁化组织）的国际组织编制的字符集可以表示世界上所有的字符，它规定用4个字节来表示字符，每个数字代表唯一的至少在某种语言中使用的符号（并不是所有的数字都用上了，但是总数已经超过了65535，所以2个字节的数字是不够用的。）在UNICODE中，每个字符对应一个数字，每个数字对应一个字符。即不存在二义性。不再需要记录”模式”了。U+0041总是代表’A’，即使这种语言没有’A’这个字符。</p>
<p>在计算机科学领域中，Unicode（统一码、万国码、单一码、标准万国码）是业界的一种标准，它可以使电脑得以体现世界上数十种文字的系统。Unicode 是基于通用字符集（Universal Character Set）的标准来发展，并且同时也以书本的形式[1]对外发表。直至目前为止的第六版，Unicode 就已经包含了超过十万个字符（在2005年，Unicode 的第十万个字符被采纳且认可成为标准之一）、一组可用以作为视觉参考的代码图表、一套编码方法与一组标准字符编码、一套包含了上标字、下标字等字符特性的枚举等。Unicode 组织（The Unicode Consortium）是由一个非营利性的机构所运作，并主导 Unicode 的后续发展，其目标在于：将既有的字符编码方案以Unicode 编码方案来加以取代，特别是既有的方案在多语环境下，皆仅有有限的空间以及不兼容的问题。</p>
<p>UNICODE这种编码方式虽然形成了一种统一的字符集，世界上的人们终于能在同一种字符集下工作了。但是他也带来了一些问题。</p>
<p>例如汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。而计算机不知道这两个字节是一个汉字，还是两个ASCLL字符。</p>
<p>用跟多的字节表示英文字符，这样浪费了大量的空间，老外们非常不高兴。</p>
<p>传输时的问题。</p>
<p>于是这个时候就有必要出现一种可以解决这个问题的全新的编码方式。于是就出现了UTF系列（utf-8,utf-16,utf-32）</p>
<p>（<strong>可以这样理解：**</strong>Unicode是字符集，UTF-32/ UTF-16/ UTF-8<strong>**是三种字符编码方案。</strong>）</p>
<p><strong>UTF-32编码方式：</strong></p>
<p>上述使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。UTF-32又称UCS-4是一种将Unicode字符编码的协定，对每个字符都使用4字节。就空间而言，是非常没有效率的。这种方法有其优点，最重要的一点就是可以在常数时间内定位字符串里的第N个字符，因为第N个字符从第4×Nth个字节开始。虽然每一个码位使用固定长定的字节看似方便，它并不如其它Unicode编码使用得广泛。</p>
<p><strong>UTF-16 编码方式</strong></p>
<p>​     尽管有Unicode字符非常多，但是实际上大多数人不会用到超过前65535个以外的字符。因此，就有了另外一种Unicode编码方式，叫做UTF-16(因为16位 = 2字节)。UTF-16将0–65535范围内的字符编码成2个字节，如果真的需要表达那些很少使用的”星芒层(astral plane)”内超过这65535范围的Unicode字符，则需要使用一些诡异的技巧来实现。这些诡异的技巧请自行百度。</p>
<blockquote>
<p><strong>小结：</strong></p>
<p><strong>对于UTF-32和UTF-16编码方式还有一些其他不明显的缺点。不同的计算机系统会以不同的顺序保存字节。这意味着字符U+4E2D在UTF-16编码方式下可能被保存为4E 2D或者2D 4E，这取决于该系统使用的是大尾端(big-endian)还是小尾端(little-endian)。这时候数据的传输就出了问题，为了解决这个问题，多字节的Unicode编码方式定义了一个”字节顺序标记(Byte Order Mark)”，它是一个特殊的非打印字符，你可以把它包含在文档的开头来指示你所使用的字节顺序。对于UTF-16，字节顺序标记是U+FEFF。如果收到一个以字节FF FE开头的UTF-16编码的文档，你就能确定它的字节顺序是单向的(one way)的了；如果它以FE FF开头，则可以确定字节顺序反向了。这就是我们在notepad++的格式选项里看到的UCS-2 BIG endian &amp; UCS-2 Little endian 的含义了。</strong></p>
</blockquote>
<p>UTF-8 编码方式</p>
<p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式，也是最重要的一种编码方式。</p>
<p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码（定长码），也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部份修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8的编码规则很简单，只有二条：</p>
<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</p>
<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
<p>下表总结了编码规则，字母x表示可用编码的位。</p>
<p>Unicode符号范围<strong> |</strong> UTF-8编码方式</p>
<p>(十六进制) | （二进制）</p>
<p>——————–+———————————————</p>
<p>0000 0000-0000 007F | 0xxxxxxx</p>
<p>0000 0080-0000 07FF | 110xxxxx 10xxxxxx</p>
<p>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</p>
<p>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p>下面，还是以汉字”严”为例，演示如何实现UTF-8编码。</p>
<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101″，转换成十六进制就是E4B8A5。</p>
<p>从上面的过程中我们可以看出在utf-8中 汉字大多是三个字节的而英文字母都是1个字节的，这样原来的英文文件就可以在不用修改的情况下来适应utf-8，也不用多余的占用空间。</p>
<p>UTF-8优点：</p>
<ol>
<li>UTF-8是ASCII的一个超集。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。</li>
<li>UTF-8字符串可以由一个简单的算法可靠地识别出来。就是，一个字符串在任何其它编码中表现为合法的UTF-8的可能性很低，并随字符串长度增长而减小。</li>
</ol>
<p><strong>Utf-8 BOM 问题：</strong></p>
<p>前面提到过”字节顺序标记(Byte Order Mark)”—-BOM 这是用来表示UTF-16和UTF-32的字节顺许的，但UTF-8并不需要他，他在utf-8文件中被编译为” EF BB BF “，占三个字节。这就是我们用记事本创建一个utf-8文件时，它的起始大小为3字节，这三个字节来标识UTF-8编码。但这三个字节会常常造成一些问题。</p>
<p>例如：</p>
<ol>
<li><em>当一个文件流是utf-8 BOM 形式编码的话，其在除IE10之外的IE中都会输出一个空行。这会导致一些页面的错乱。</em></li>
<li><em>受COOKIE送出机制的限制，在这些文件开头已经有BOM的文件中，COOKIE无法送出（因为在COOKIE送出前PHP已经送出了文件头），所以登入和登出功能失效。一切依赖COOKIE、SESSION实现的功能全部无效。</em></li>
</ol>
<p>解决办法：</p>
<p>使用notepad++编辑器打开文件，在”格式”选项中选择”转为UTF-8无BOM格式”。</p>
<p><strong>ANSI 是神马？？</strong></p>
<p>在notepad++中的”格式”选项中，我们可以看到”以ANSI编码”这个选项，那么，ANSI究竟是什么呢？？？</p>
<blockquote>
<p>为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 2 个字节来表示 1 个字符。比如：汉字 ‘中’ 在中文操作系统中，使用 [0xD6,0xD0] 这两个字节存储。不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中。</p>
</blockquote>
<p>ANSI 就是一种对双字节编码方式的总称，我们可以把它看做一个变量，在不同的地域，他的值是不同的。而这个地域的判断又是依赖于操作系统。在中国，ANSI=GB2312，在日本，ANSI=JIS。有的时候ANSI也被称为’本地编码’。事实上，ANSI的值取决于windows的’codepage’，你可以在命令行下输入”chcp”来查看你的codepage，一般为936，然后查看cmd的属性时，你会发现codepage时GBK。</p>
<p>说了半天，也就是在中国，你的ANSI就是GB2312。文本以ANSI的形式存储或处理时，就是以GB2312处理的。</p>
<p>举个例子：</p>
<p>比 如 一个用户在简体中文Windows下面用记事本输入一些汉字后保存，然后copy到另一台英文Windows上，尝试用记事本打开，就会发现出现的是一 些乱码。并不是copy的过程中出现了错误，而是因为在英文的Windows上打开文件时默认的ANSI编码是Wenstern European(Windows) – Codepage 1252，而在简体中文的Windows上保存打开时默认的编码格式是Chinese Simplified(GB2312) – Codepage 936。</p>
<p><strong>实验课</strong></p>
<p>新建5个txt文件分别命名为”utf-8.txt”,”gb2312.txt”,”ANSI.txt”,”Unicode big endian,txt”,”Unicode little endian.txt”，然后用notepad++打开，将其改变为名称对应的编码方式。然后在里面都输入’严’</p>
<p>然后，使用Ultraedit 打开，按下’ctrl+H’查看他们的十六进制码。</p>
<blockquote>
<ul>
<li><p>ANSI：文件的编码就是两个字节”D1 CF”，这正是”严”的GB2312编码。:</p>
</li>
<li><p>Gb2312：文件的编码就是两个字节”D1 CF”，和ANSI一样。</p>
</li>
<li><p>Unicode litte endian：编码是四个字节”FF FE 25 4E”，其中”FF FE”表明是小头方式存储，真正的编码是4E25。</p>
</li>
<li><p>Unicode big endian：编码是四个字节”FE FF 4E 25″，其中”FE FF”表明是大头方式存储。</p>
</li>
<li><p>UTF-8：编码是六个字节”EF BB BF E4 B8 A5″，前三个字节”EF BB BF”表示这是UTF-8编码，后三个”E4B8A5″就是”严”的具体编码，它的存储顺序与编码顺序是一致的。</p>
<p>​</p>
<p>参考资料及延伸阅读：</p>
<p><a href="http://blog.csdn.net/stilling2006/article/details/4129700" target="_blank" rel="noopener">http://blog.csdn.net/stilling2006/article/details/4129700</a></p>
<p><a href="http://www.pconline.com.cn/pcedu/empolder/gj/other/0505/616631.html" target="_blank" rel="noopener">http://www.pconline.com.cn/pcedu/empolder/gj/other/0505/616631.html</a></p>
<p><a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="noopener">http://www.joelonsoftware.com/articles/Unicode.html</a></p>
<p><a href="http://www.crifan.com/files/doc/docbook/char_encoding/release/webhelp/content/" target="_blank" rel="noopener">http://www.crifan.com/files/doc/docbook/char_encoding/release/webhelp/content/</a></p>
<p><a href="http://huaichang.blogbus.com/logs/19602597.html" target="_blank" rel="noopener">http://huaichang.blogbus.com/logs/19602597.html</a></p>
</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">liukai93</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liukai93</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
